"""
Main trading engine that coordinates AI predictions with trading execution
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import pandas as pd
import numpy as np

try:
    from loguru import logger
except ImportError:
    import logging
    logger = logging.getLogger(__name__)


class SignalType(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class OrderStatus(Enum):
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class TradingSignal:
    """Trading signal generated by AI model"""
    symbol: str
    signal_type: SignalType
    confidence: float
    predicted_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timestamp: datetime = None
    reason: str = ""
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


@dataclass
class Position:
    """Active trading position"""
    symbol: str
    side: str  # 'long' or 'short'
    size: float
    entry_price: float
    current_price: float
    unrealized_pnl: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    entry_time: datetime = None
    
    def __post_init__(self):
        if self.entry_time is None:
            self.entry_time = datetime.now()


class TradingEngine:
    """
    Main trading engine that coordinates data, AI predictions, and trade execution
    """
    
    def __init__(self, settings, inference_engine):
        self.settings = settings
        self.inference_engine = inference_engine
        self.active_positions: Dict[str, Position] = {}
        self.pending_orders: List[Dict] = []
        self.trade_history: List[Dict] = []
        self.portfolio_value = 10000.0  # Starting portfolio value (simulation)
        self.cash_balance = self.portfolio_value
        self.daily_pnl = 0.0
        self.total_pnl = 0.0
        self.max_drawdown = 0.0
        self.peak_portfolio_value = self.portfolio_value
        
        # Risk management
        self.max_position_size = settings.MAX_POSITION_SIZE
        self.stop_loss_pct = settings.STOP_LOSS_PERCENTAGE
        self.take_profit_pct = settings.TAKE_PROFIT_PERCENTAGE
        self.max_daily_loss = settings.MAX_DAILY_LOSS
        self.max_drawdown_limit = settings.MAX_DRAWDOWN
        
        # Performance tracking
        self.signals_generated = 0
        self.successful_trades = 0
        self.failed_trades = 0
        
        logger.info(f"Trading engine initialized in {settings.TRADING_MODE} mode")
    
    async def process_market_data(self, market_data: Dict[str, pd.DataFrame]) -> List[TradingSignal]:
        """Process market data and generate trading signals using AI"""
        signals = []
        
        for symbol, data in market_data.items():
            try:
                if len(data) < 60:  # Need at least 60 periods for most indicators
                    logger.warning(f"Insufficient data for {symbol}: {len(data)} rows")
                    continue
                
                signal = await self._generate_signal(symbol, data)
                
                if signal:
                    signals.append(signal)
                    self.signals_generated += 1
                    
            except Exception as e:
                logger.error(f"Error processing market data for {symbol}: {e}")
        
        return signals
    
    async def _generate_signal(self, symbol: str, market_data: pd.DataFrame) -> Optional[TradingSignal]:
        """Generate trading signal for a specific symbol"""
        
        try:
            # Preprocess data for AI model
            processed_data = self.inference_engine.preprocess_data(market_data)
            
            # Get AI prediction
            prediction = self.inference_engine.predict(processed_data)
            
            # Check confidence threshold
            if prediction['confidence'] < self.settings.CONFIDENCE_THRESHOLD:
                logger.debug(f"Low confidence prediction for {symbol}: {prediction['confidence']:.2f}")
                return None
            
            # Convert AI prediction to trading signal
            signal = self._ai_prediction_to_signal(symbol, market_data, prediction)
            
            # Apply additional filters and risk checks
            if signal and self._validate_signal(signal, market_data):
                return signal
            
        except Exception as e:
            logger.error(f"Error generating signal for {symbol}: {e}")
        
        return None
    
    def _ai_prediction_to_signal(self, symbol: str, market_data: pd.DataFrame, 
                                prediction: Dict[str, Any]) -> Optional[TradingSignal]:
        """Convert AI prediction to trading signal"""
        
        current_price = float(market_data['close'].iloc[-1])
        
        if prediction['prediction_type'] == 'direction':
            direction = prediction['predicted_direction']
            confidence = prediction['confidence']
            
            # Determine signal type
            if direction == 'up' and confidence > self.settings.CONFIDENCE_THRESHOLD:
                signal_type = SignalType.BUY
            elif direction == 'down' and confidence > self.settings.CONFIDENCE_THRESHOLD:
                signal_type = SignalType.SELL
            else:
                signal_type = SignalType.HOLD
            
            # Calculate stop loss and take profit
            if signal_type == SignalType.BUY:
                stop_loss = current_price * (1 - self.stop_loss_pct)
                take_profit = current_price * (1 + self.take_profit_pct)
            elif signal_type == SignalType.SELL:
                stop_loss = current_price * (1 + self.stop_loss_pct)
                take_profit = current_price * (1 - self.take_profit_pct)
            else:
                stop_loss = take_profit = None
            
            return TradingSignal(
                symbol=symbol,
                signal_type=signal_type,
                confidence=confidence,
                predicted_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                reason=f"AI direction prediction: {direction} (confidence: {confidence:.2f})"
            )
        
        return None
    
    def _validate_signal(self, signal: TradingSignal, market_data: pd.DataFrame) -> bool:
        """Validate trading signal against risk management rules"""
        
        # Check if we already have a position in this symbol
        if signal.symbol in self.active_positions:
            existing_position = self.active_positions[signal.symbol]
            
            # Don't open opposite position
            if (existing_position.side == 'long' and signal.signal_type == SignalType.SELL) or \
               (existing_position.side == 'short' and signal.signal_type == SignalType.BUY):
                logger.debug(f"Skipping {signal.signal_type.value} signal for {signal.symbol} - opposite position exists")
                return False
        
        # Check daily loss limit
        if self.daily_pnl <= -self.max_daily_loss * self.portfolio_value:
            logger.warning(f"Daily loss limit reached: {self.daily_pnl:.2f}")
            return False
        
        # Check if signal is HOLD
        if signal.signal_type == SignalType.HOLD:
            return False
        
        return True
    
    async def execute_trades(self, signals: List[TradingSignal]):
        """Execute trades based on generated signals"""
        
        for signal in signals:
            try:
                await self._execute_single_trade(signal)
            except Exception as e:
                logger.error(f"Failed to execute trade for {signal.symbol}: {e}")
    
    async def _execute_single_trade(self, signal: TradingSignal):
        """Execute a single trade"""
        
        if self.settings.TRADING_MODE == "simulation":
            await self._simulate_trade(signal)
        else:
            await self._execute_real_trade(signal)
    
    async def _simulate_trade(self, signal: TradingSignal):
        """Simulate trade execution for backtesting and paper trading"""
        
        # Calculate position size
        position_value = self.portfolio_value * self.max_position_size
        
        # Simulate current market price
        current_price = signal.predicted_price or 0.0
        
        if signal.signal_type == SignalType.BUY:
            # Open long position
            position_size = position_value / current_price
            
            if self.cash_balance >= position_value:
                position = Position(
                    symbol=signal.symbol,
                    side='long',
                    size=position_size,
                    entry_price=current_price,
                    current_price=current_price,
                    unrealized_pnl=0.0,
                    stop_loss=signal.stop_loss,
                    take_profit=signal.take_profit
                )
                
                self.active_positions[signal.symbol] = position
                self.cash_balance -= position_value
                
                logger.info(f"Opened LONG position: {signal.symbol} @ {current_price:.2f} (size: {position_size:.4f})")
                
                # Record trade
                self.trade_history.append({
                    'timestamp': datetime.now(),
                    'symbol': signal.symbol,
                    'action': 'BUY',
                    'price': current_price,
                    'size': position_size,
                    'value': position_value,
                    'confidence': signal.confidence,
                    'reason': signal.reason
                })
            else:
                logger.warning(f"Insufficient cash for {signal.symbol} trade")
        
        elif signal.signal_type == SignalType.SELL:
            # Close long position if exists
            if signal.symbol in self.active_positions:
                await self._close_position(signal.symbol, current_price, "AI sell signal")
    
    async def _execute_real_trade(self, signal: TradingSignal):
        """Execute real trade on exchange (placeholder)"""
        logger.warning("Real trading not implemented yet - this would connect to exchange API")
    
    async def _close_position(self, symbol: str, exit_price: float, reason: str):
        """Close an existing position"""
        
        if symbol not in self.active_positions:
            logger.warning(f"No position to close for {symbol}")
            return
        
        position = self.active_positions[symbol]
        
        # Calculate P&L
        if position.side == 'long':
            pnl = (exit_price - position.entry_price) * position.size
        else:  # short
            pnl = (position.entry_price - exit_price) * position.size
        
        # Update portfolio
        self.cash_balance += (exit_price * position.size)
        self.total_pnl += pnl
        self.daily_pnl += pnl
        
        # Track success/failure
        if pnl > 0:
            self.successful_trades += 1
        else:
            self.failed_trades += 1
        
        logger.info(f"Closed {position.side.upper()} position: {symbol} @ {exit_price:.2f} | P&L: {pnl:.2f}")
        
        # Record trade
        self.trade_history.append({
            'timestamp': datetime.now(),
            'symbol': symbol,
            'action': 'SELL',
            'price': exit_price,
            'size': position.size,
            'pnl': pnl,
            'reason': reason
        })
        
        # Remove position
        del self.active_positions[symbol]
    
    async def close_all_positions(self):
        """Close all active positions"""
        logger.info("Closing all active positions...")
        
        for symbol in list(self.active_positions.keys()):
            position = self.active_positions[symbol]
            await self._close_position(symbol, position.current_price, "System shutdown")
        
        logger.info("All positions closed")
    
    def get_portfolio_summary(self) -> Dict[str, Any]:
        """Get current portfolio summary"""
        
        # Calculate total portfolio value
        positions_value = sum(pos.current_price * pos.size for pos in self.active_positions.values())
        total_portfolio_value = self.cash_balance + positions_value
        
        # Calculate unrealized P&L
        unrealized_pnl = sum(pos.unrealized_pnl for pos in self.active_positions.values())
        
        # Calculate returns
        total_return = (total_portfolio_value - 10000.0) / 10000.0
        
        # Calculate win rate
        total_trades = self.successful_trades + self.failed_trades
        win_rate = self.successful_trades / total_trades if total_trades > 0 else 0
        
        return {
            'cash_balance': self.cash_balance,
            'positions_value': positions_value,
            'total_portfolio_value': total_portfolio_value,
            'total_pnl': self.total_pnl,
            'daily_pnl': self.daily_pnl,
            'unrealized_pnl': unrealized_pnl,
            'total_return': total_return,
            'active_positions': len(self.active_positions),
            'signals_generated': self.signals_generated,
            'successful_trades': self.successful_trades,
            'failed_trades': self.failed_trades,
            'win_rate': win_rate,
            'max_drawdown': self.max_drawdown
        }
